{
	"claritatea.netlify.app/": {
		"description": "Magazine website presenting the newest issues, live updates, physical copy order and newsletter. Implemented using vanilla JS. It contains a password-protected admin pannel that allows the magazine creators to update the website without scripting knowledge. Github: https://github.com/GandalfTea/claritatea.ro",
		"tabs": {
			"0": {
				"name": "Landing",
				"desktop": "./assets/claritatea_desktop.png",
				"mobile": "./assets/claritatea_mobile.png",
				"numcom" : "3",
				"comments": {

					"0": {
						"text": "Student Art Carousel with buttons and author. In the future, articles and painting will be submited through this website and filtered in the admin page on a custom server.",
						"depth": "250"
					},

					"1": {
						"text": "Custom cursor carousel of older magazines.",
						"depth" : "1500"
					},
							
					"2": {
						"text": "RESTful API news section updated from separate password-protected admin panel.",
						"depth": "1800"
					}
				}
			}
		},
        "name": "Magazine Website with RESTful API",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "Being responsible for the Graphic Design and Front-End Development of the Claritatea artistic magazine website and working closely with the magazine coordinators, I have created its online presence in accordance with the brand guidelines and accessibility requests. The website can be used from any device and with any browser. It showcases various visual creations submitted by the local students, allows the user to order physical copies and future contributors and sponsors to contact the representatives in a couple of clicks.",
            "1": "The implementation was done in Vanilla JS with jQuery. It is a static website, but uses a RESTful API for the news section, editable from a password-protected sha-512 login admin panel. On every load, the user will get the latest news. The user can also sign up for the newsletter. ",
            "2": "Because the management of the magazine has gone through some changes in the past months, they have yet to purchase the final domain for the website, claritatea.ro and it is thus hosted on netlify for the time being."
        }
	},


	"stejar.casa": {
		"description": "House presentation website done for private client. It extensive use of videos, a 3D Terrain and House placement model made with Three.js and a Google Maps API embeded easy localisation. It also contains a detailed construction album page that separates each step of construction with a brief description and a set of site pictures.",
		"tabs": {
			"0" : {
				"name": "Landing",
				"desktop": "./assets/stejarcasa_desktop.png",
				"mobile": "./assets/stejarcasa_mobile.png",
				"numcom": "4",
				"comments": {
					"0": {
						"text": "Autoplay 3D render video of the house.",
						"depth": "300"
					},
	
					"1": {
						"text": "Three.js House Model. Movable with a mouse click.",
							"depth": "900"
					},

					"2": {
						"text": "Quick view of construction in current state. More detailed pictures can be found in the Construction tab.",
						"depth": "1650"
					},

					"3": {
						"text": "Google Maps API embeding with Contact form and details.",
						"depth": "2430"
					}
				}	
			},
			"1": {
				"name": "Construction",
				"desktop": "./assets/stejarcasa_img_desktop.png",
				"mobile": "./assets/stejarcasa_img_mobile.png",
				"numcom": "1",
				"comments": {
					"0": {
						"text": "Image viewer, separated into the individual construction stages for an easy structural overview. The page has two different viewing options, depending on weather is it accessed on desktop or mobile. The stage selector on the right updates depending on what you are viewing automatically.",
						"depth": "0"
					}
				}	
			}
		},
        "name": "House Presentation Website",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "This is a freelance contact, offering me much more freedom to work again, as both Graphic Designer and Developer. Presenting real estate in a modern way, it makes use of 3D models implemented in Three.js and detailed video breakdowns of the different levels completely furnished for clear terrain and houses visualization, giving the user a good understanding of what is being sold.",
            "1": "The main challenge was managing the total size of the website. Storing 3 videos and a 3D model puts a strain on the load time. This was solved using lazy loading and various methods for video compression without noticeable loss of quality. The total size of the website after optimization ended up being 2 Mb initial and just over 9Mb total, down from an initial 50-60Mb.",
            "2": "Another challenge was the construction documentation page, which contained a total of 70 images. A quick image preview and image viewer was constructed for the desktop view. For mobile devices, a separate viewing mode that tracked page scroll and automatically opened images was devised for ease of use."
        }
	},


	"braket.ai" : {
		"tabs": {
			"0": {
				"name": "Dataset Presentation",
                "description": "This project is still in it's initial prototype phase. Dataset Maeketplace with Source Control. Below is the UI design, built in React.js, for the dataset presentation page. It was designed to easily convey to the user quickly if the dataset is useful for one's situation. It does this with a short description, a longer README type description where the creators can go in depth, a data format and snippet visualiser, a code section that highlightes popular code that uses the dataset in question for a practical demo of use cases, an Issues section to highlight what contributors should work towards and a Discussion section for public forum-like discussion. While just a demo for now, in the future, users shall be able to simply copy the CDN URL present on the dataset card and paste it into a CLI console interface for quick and easy remote access to the dataset, voiding the need for a full download. The right side panel contains basic information, as well as credit, sources and tags."
			},
			"1": {
				"name": "Landing",
                "description" : "Below are a couple of UI elements for a logged in Landing page, the notifications for a returning user. In order, they are a Contribution Update Notification, for open-source dataset contributions, much like GitHub pull requests, a Private Message Notification, a Message Reply Notification, built with a recursive function that is invariant to the number of replies or their level, and finally a Contribution Request Notification, made for dataset admins to request each contributor to update a certain number of entries by a certain deadline."
			},
			"2": {
				"name": "Search",
                "description": "Below are the UI elements made for rapid dataset preview, mostly used in searches. It was engineered to give the user all the necesary information about the usefulness of a dataset in a clear and concise way. It contains pricing and licence information, data structure and preview as well as a description and user-driven upvote system."
			}
		},
        "name": "AI Dataset Marketplace and Crowd-Sourcing",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "Still a work in progress, this is one of my own personal projects. It centers around a dataset marketplace that seconds as a crowd-sourcing tool for creating and maintaining datasets. It should offer the ability to either download a new dataset filetype or simply access the data from the server remotely, voiding the need to store it on the client computer. To allow for this, it contains both a Command Line Interface and an API.",
            "1": "As of now, elements of the main website have been created, mainly the logged in landing page, search result page and dataset presentation page. Built in React.js and JSX, the components are built around JSON data files and are thus modular for any incoming data from the server. ",
            "2": "Extensive attention has been given to the UI and UX elements, optimizing for ease of use and easy information transmission. The full UX framework was applied while building, doing user testing, persona building, accessibility checks, etc."
        }
	},



    "lists.directory" : {
        "description": "Minimalist but powerful TODO list. Made to start typing as soon as it loads. QR Code or Base64 URL share and Local Memory Storage. The user can also change the background color from the presets at the bottom, or input a color hex code.",
		"tabs": {
			"0" : {
				"name": "Landing",
				"desktop": "./assets/listsdirectory_desktop.png",
				"mobile": "./assets/NULL.png",
				"numcom": "3",
				"comments": {
					"0": {
						"text": "Movable tasks, with important marker.",
						"depth": "250"
					},
	
					"1": {
						"text": "QR Code or Base64 URL Share.",
							"depth": "550"
					},

					"2": {
						"text": "Local storage saves.",
						"depth": "900"
					}
				}	
			}
        },
        "name": "Minimalist TODO List",
        "par_num": "2",
        "img": "false",
        "text": {
            "0": "A streamlined minimalist to do list website with QR or Base64 link share. This is another personal project stemming from the need of a quick access link and start typing website. The created list can be saved in browser local memory for later access, or sent over to other devices by simply scaling the generated QR code with a smartphone camera. If this is unavailable, there is also the generated base64 variable link that can be sent over any text messenger.",
            "1": "Because I am probably the main user of this website, I have optimized it for myself. It makes use of  keyboard shortcuts and other small tools to speed up the flow. While coding, I can create a todo list in a matter of seconds."
        }
    },


    "louisgeorge.me" : {
        "description": "",
		"tabs": {
			"0" : {
				"name": "Landing",
				"desktop": "./assets/louisgeorgeme_desktop.png",
				"mobile": "./assets/NULL.png",
				"numcom": "3",
				"comments": {
					"0": {
						"text": "Movable tasks, with important marker.",
						"depth": "250"
					},
	
					"1": {
						"text": "QR Code or Base64 URL Share.",
							"depth": "550"
					},

					"2": {
						"text": "Local storage saves.",
						"depth": "900"
					}
				}	
			}
        }
    },

    "4D" : {
        "name": "Hyperdimensional Object Visualizer",
        "par_num": "2",
        "img": "false",
        "text": {
            "0": "Another personal project, this one showcases the speed of my learning and the various interests and the innate curiosity that follows all of my work. Following discussions with my Physicist housemates about the nature of space, we have arrived at a standstill because our understanding of 4 dimensional space was lacking. Upon research, we found no visualization worthy of thought. Because of this, we took it upon ourselves to devise a way of visualizing 4D in a more realistic way. Using the same tools as Minkowski spacetime in General Relativity, I coded a C++ OpenGL visualizer and devised projective transformations that allow us to view 4D in various ways.",
            "1": "To allow for ease of use, without CMake and a terminal, I transcompiled it with emscripten for use with Web Assembly as a website."
        }
    },


    "SLAM" : {
        "name": "SLAM with Extended Kalman Filter with Symbolic Jacobian Computation",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "Simultaneous Localization and Mapping algorithm made in C++ with an Extended Kalman filter that makes use of Symbolic Jacobian Matrices for state transitions. This is still a work in progress, so the contents of the EKF state are still variable. Since the main use of this filter is for tracking an inside environment for Extended Reality boundary-checking, it must focus mainly on rotation, but also track displacement and velocity. Because of this, the state uses a Quaternion for tracking rotation, a vector for motion and a compound Map for storing and correcting found environment features.",
            "1": "This is part of a bigger library, named MRCV, Mixed Reality Computer Vision, currently developed by myself, that should allow users to easily experiment with DIY Head Mounted Displays or various game features without having to worry about the mathematical side of reproducible environment tracking. It is built to support either a monocular or multi-camera setup and allow the user to easily calibrate the system to their own intrinsic camera matrix. At the same time, it is lightweight, not using a lot of memory or CPU as a background process. Ideally, it should run on a Raspberry PI Zero 2, to make it as accessible to users as possible.",
            "2" : "It makes use of OpenCV, OpenGL, Pangolin for visualization with a custom view Handler to support mouse motion rotation, and matplotlibcpp for plotting displacement and other tracked values. As of now, it uses the OpenCV Essential Matrix extractor function, ORB feature extractor and BFMatcher, but this is likely to change as the library progresses, implementing the algorithms from scratch for better optimisation."
        }
    },

    "Engine": {
        "name": "Rudimentary Game Engine with Procedurally Generated Terrain",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "A barebones game engine made in C++ with Procedurally Generated Terrain by Perlin Noise. It contains an .OBJ file loader for easy model loading, First Person Character, Primitive Shape Generator, 3D Model Visualiser, Collision, etc. No external libraries were used to build it, outside OpenGL. It contains personalized primitive Matrix, Vector, Quaternion and Euler Angle classes that combine into an abstract Object class, from which all in-game objects are derived. In the future, it will be able to do Procedural Terrain Destruction and Physics Simulations.",
            "1" : "The core low-level classes have been thoroughly tested for sanity and performance. The Matrix and Vector are template classes that make use of various predefined types of certain byte depth, like U32C3, an unsigned integer of 32-bits depth with 3 channels. They are very user-friendly, the interface being something in between Eigen matrices and OpenCV matrices. There are also specialized constructors that create various rotation, translation, scaling or compound matrices. The coordinate-storing classes, Quaternion, Euler Angles and Rotation Matrices, are very easily interchangeable and have various helpers and automations that make them easy to use. The abstract Object class uses Quaternions to store rotation, but this can easily be changed.",
            "2" : "The procedural terrain is made using Perlin Noise and Fractals to enhance realism. The noise is generated from 0 using our own vector class and a smooth-step interpolation function. As the other generated primitives, we compute collision, normals and topography for it. The resolution, scaling and other variables are left to the user, offering a lot of  degrees of freedom for how the terrain should look. For a full explanation, please check the Docs in the GitHub repo. It also contains some demos to test, compiled with CMake."
        },
        "images": {
            "0": "",
            "1": ""
        }
    },

    "Market": {
        "name": "Financial Market Simulation",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "A financial market simulator with a varying number of securities and agents implemented in Python using Numpy. It was initially made to test the effects and behavior of prediction markets and overall speculation-driven agents on a market user-structure. It contains a complex Command Line Interface that allows the user to change a lot of variables before running the simulation. It also allows them to set breakpoints, where the simulation automatically pauses and captures a full state snapshot for visualization. If you choose not to use the CLI, it also contains various command-line level arguments and options.",
            "1": "It is initialized with a set number of participants that each have a random sum of money distributed in an exponential fashion, random risk tolerance variable that updates after each cycle, personal bias vector to introduce irrational behavior as well as buy and sell algorithms. Each cycle, the participants update most of the variables based on the results of the last cycle.",
            "2": "The Market Maker algorithm is pretty straight forward, it caches and completes orders and partial orders.  The price of the order can either be set by the participant or automatically executed to the highest ( or lowest ) already existing order. The state of the market can be dumped at any point during the simulation, displaying nicely in the console window. As this program was developed on Linux, it makes use of ANSI colors and console commands to display the data in a nice user readable format, which might not work on Windows."
        }
    }
}
