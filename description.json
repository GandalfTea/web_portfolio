{
	"claritatea.netlify.app/": {
		"description": "Being responsible for the Graphic Design and Front-End Development of the Claritatea artistic magazine website and working closely with the magazine coordinators, I have created its online presence in accordance with the brand guidelines and accessibility requests. The website can be used from any device and with any browser. It showcases various visual creations submitted by the local students, allows the user to order physical copies and future contributors and sponsors to contact the representatives in a couple of clicks. The implementation was done in Vanilla JS with jQuery. It is a static website, but uses a RESTful API for the news section, editable from a password-protected SHA-512 login admin panel. On every load, the user will get the latest news. The user can also sign up for the newsletter.",
		"tabs": {
			"0": {
				"name": "Landing",
				"desktop": "./assets/claritatea_desktop.png",
				"mobile": "./assets/claritatea_mobile.png",
				"numcom" : "3",
				"comments": {

					"0": {
						"text": "Student Art Carousel with buttons and author. In the future, articles and painting will be submited through this website and filtered in the admin page on a custom server.",
						"depth": "250"
					},

					"1": {
						"text": "Custom cursor carousel of older magazines.",
						"depth" : "1500"
					},
							
					"2": {
						"text": "RESTful API news section updated from separate password-protected admin panel.",
						"depth": "1800"
					}
				}
			}
		},
        "name": "Magazine Website with RESTful API",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "Being responsible for the Graphic Design and Front-End Development of the Claritatea artistic magazine website and working closely with the magazine coordinators, I have created its online presence in accordance with the brand guidelines and accessibility requests. The website can be used from any device and with any browser. It showcases various visual creations submitted by the local students, allows the user to order physical copies and future contributors and sponsors to contact the representatives in a couple of clicks.",
            "1": "The implementation was done in Vanilla JS with jQuery. It is a static website, but uses a RESTful API for the news section, editable from a password-protected sha-512 login admin panel. On every load, the user will get the latest news. The user can also sign up for the newsletter. ",
            "2": "Because the management of the magazine has gone through some changes in the past months, they have yet to purchase the final domain for the website, claritatea.ro and it is thus hosted on netlify for the time being."
        }
	},


	"stejar.casa": {
		"description": "This is a freelance contact, working as both Graphic Designer and Developer. Presenting real estate in a modern way, it makes use of 3D models implemented in Three.js and detailed video breakdowns of the different levels completely furnished for clear terrain and houses visualization, giving the user a good understanding of what is being sold. The main challenge was managing the total size of the website. This was solved using lazy loading and various methods for video compression without noticeable loss of quality. The total size of the website after optimization ended up being 2 Mb initial and just over 9Mb total, down from an initial 50-60Mb. Another challenge was the construction documentation page, which contained a total of 70 images. A quick image preview and image viewer was constructed for the desktop view. For mobile devices, a separate viewing mode that tracked page scroll and automatically opened images was devised for ease of use.",
		"tabs": {
			"0" : {
				"name": "Landing",
				"desktop": "./assets/stejarcasa_desktop.png",
				"mobile": "./assets/stejarcasa_mobile.png",
				"numcom": "4",
				"comments": {
					"0": {
						"text": "Autoplay 3D render video of the house.",
						"depth": "300"
					},
	
					"1": {
						"text": "Three.js House Model. Movable with a mouse click.",
							"depth": "900"
					},

					"2": {
						"text": "Quick view of construction in current state. More detailed pictures can be found in the Construction tab.",
						"depth": "1650"
					},

					"3": {
						"text": "Google Maps API embeding with Contact form and details.",
						"depth": "2430"
					}
				}	
			},
			"1": {
				"name": "Construction",
				"desktop": "./assets/stejarcasa_img_desktop.png",
				"mobile": "./assets/stejarcasa_img_mobile.png",
				"numcom": "1",
				"comments": {
					"0": {
						"text": "Image viewer, separated into the individual construction stages for an easy structural overview. The page has two different viewing options, depending on weather is it accessed on desktop or mobile. The stage selector on the right updates depending on what you are viewing automatically.",
						"depth": "0"
					}
				}	
			}
		},
        "name": "House Presentation Website",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "This is a freelance contact, offering me much more freedom to work again, as both Graphic Designer and Developer. Presenting real estate in a modern way, it makes use of 3D models implemented in Three.js and detailed video breakdowns of the different levels completely furnished for clear terrain and houses visualization, giving the user a good understanding of what is being sold.",
            "1": "The main challenge was managing the total size of the website. Storing 3 videos and a 3D model puts a strain on the load time. This was solved using lazy loading and various methods for video compression without noticeable loss of quality. The total size of the website after optimization ended up being 2 Mb initial and just over 9Mb total, down from an initial 50-60Mb.",
            "2": "Another challenge was the construction documentation page, which contained a total of 70 images. A quick image preview and image viewer was constructed for the desktop view. For mobile devices, a separate viewing mode that tracked page scroll and automatically opened images was devised for ease of use."
        }
	},


	"braket.ai" : {
		"tabs": {
			"0": {
				"name": "Dataset Presentation",
                "description": "Still a work in progress, this is one of my own personal projects. It centers around a dataset marketplace that seconds as a crowd-sourcing tool for creating and maintaining datasets. It should offer the ability to either download a new dataset filetype or simply access the data from the server remotely, voiding the need to store it on the client computer. To allow for this, it contains both a Command Line Interface and an API. Below is the dataset presentation page, written in React.js and JSX. The modular react components center around a JSON file that should be received from the server."
			},
			"1": {
				"name": "Landing",
         "description" : "Below are a couple of UI elements for a logged in Landing page, the notifications for a returning user. The Message Reply Notification is built with a recursive function that is invariant to the number of replies or their level."
			},
			"2": {
				"name": "Search",
        "description": "Below are the UI elements made for rapid dataset preview, mostly used in searches. It was designed to give the user all the necessary information about the usefulness of a dataset in a clear and concise way."
			}
		},
        "name": "AI Dataset Marketplace and Crowd-Sourcing",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "Still a work in progress, this is one of my own personal projects. It centers around a dataset marketplace that seconds as a crowd-sourcing tool for creating and maintaining datasets. It should offer the ability to either download a new dataset filetype or simply access the data from the server remotely, voiding the need to store it on the client computer. To allow for this, it contains both a Command Line Interface and an API.",
            "1": "As of now, elements of the main website have been created, mainly the logged in landing page, search result page and dataset presentation page. Built in React.js and JSX, the components are built around JSON data files and are thus modular for any incoming data from the server. ",
            "2": "Extensive attention has been given to the UI and UX elements, optimizing for ease of use and easy information transmission. The full UX framework was applied while building, doing user testing, persona building, accessibility checks, etc."
        }
	},



    "lists.directory" : {
        "description": "A streamlined minimalist to do list website with QR or Base64 link share. This is another personal project stemming from the need of a quick load and start typing website. The created list can be saved in browser local memory for later access or sent over to other devices by simply scanning the generated QR code with a smartphone camera. If this is unavailable, there is also the generated base64 variable link that can be sent over any text messenger.",
		"tabs": {
			"0" : {
				"name": "Landing",
				"desktop": "./assets/listsdirectory_desktop.png",
				"mobile": "./assets/listsdirectory_mobile.png",
				"numcom": "3",
				"comments": {
					"0": {
						"text": "Movable tasks, with important marker.",
						"depth": "250"
					},
	
					"1": {
						"text": "QR Code or Base64 URL Share.",
							"depth": "550"
					},

					"2": {
						"text": "Local storage saves.",
						"depth": "900"
					}
				}	
			}
        },
        "name": "Minimalist TODO List",
        "par_num": "2",
        "img": "false",
        "text": {
            "0": "A streamlined minimalist to do list website with QR or Base64 link share. This is another personal project stemming from the need of a quick load and start typing website. The created list can be saved in browser local memory for later access or sent over to other devices by simply scanning the generated QR code with a smartphone camera. If this is unavailable, there is also the generated base64 variable link that can be sent over any text messenger.",
            "1": "Because I am probably the main user of this website, I have optimized it for myself. It makes use of  keyboard shortcuts and other small tools to speed up the flow. While coding, I can create a todo list in a matter of seconds."
        }
    },


    "louisgeorge.me" : {
        "description": "",
		"tabs": {
			"0" : {
				"name": "Landing",
				"desktop": "./assets/louisgeorgeme_desktop.png",
				"mobile": "./assets/NULL.png",
				"numcom": "3",
				"comments": {
					"0": {
						"text": "Movable tasks, with important marker.",
						"depth": "250"
					},
	
					"1": {
						"text": "QR Code or Base64 URL Share.",
							"depth": "550"
					},

					"2": {
						"text": "Local storage saves.",
						"depth": "900"
					}
				}	
			}
        }
    },

    "4D" : {
        "name": "Hyperdimensional Object Visualizer",
        "par_num": "1",
        "img": "false",
        "text": {
            "0": "Another  personal  project  still  in  development,  it  contains  a  full  graphic  architecture  made  in  OpenGL  to  create and visualize 4-dimensional objects and various projective transformations. It makes use of symbolic matrices and standard in-memory 3D model data types. Written in C++, it is meant to be cross compiled with emscripten and embedded in a website with Web Assembly. This project showcases the breadth of my curiosity, having been conceptualized from discussions with my physicist friends."
        }
    },


    "SLAM" : {
        "name": "SLAM with Extended Kalman Filter with Symbolic Jacobian Computation",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "Simultaneous Localization and Mapping algorithm made in C++ with an Extended Kalman filter that makes use of Symbolic Jacobian Matrices for state transitions. This is still a work in progress, so the contents of the EKF state are still variable. Since the main use of this filter is for tracking an inside environment for Extended Reality boundary-checking, it must focus mainly on rotation, but also track displacement and velocity. Because of this, the state uses a Quaternion for tracking rotation, a vector for motion and a compound Map for storing and correcting found environment features.",
            "1": "This is part of a bigger library, named MRCV, Mixed Reality Computer Vision, currently developed by myself, that should allow users to easily experiment with DIY Head Mounted Displays or various game features without having to worry about the mathematical side of reproducible environment tracking. It is built to support either a monocular or multi-camera setup and allow the user to easily calibrate the system to their own intrinsic camera matrix. At the same time, it is lightweight, not using a lot of memory or CPU as a background process. Ideally, it should run on a Raspberry PI Zero 2, to make it as accessible to users as possible.",
            "2" : "It makes use of OpenCV, OpenGL, Pangolin for visualization with a custom view Handler to support mouse motion rotation, and matplotlibcpp for plotting displacement and other tracked values. As of now, it uses the OpenCV Essential Matrix extractor function, ORB feature extractor and BFMatcher, but this is likely to change as the library progresses, implementing the algorithms from scratch for better optimisation."
        }
    },

    "Engine": {
        "name": "Rudimentary Game Engine with Procedurally Generated Terrain",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "A barebones game engine made in C++ with Procedurally Generated Terrain by Perlin Noise. It contains an .OBJ file loader for easy model loading, First Person Character, Primitive Shape Generator, 3D Model Visualiser, Collision, etc. No external libraries were used to build it, outside OpenGL. It contains personalized primitive Matrix, Vector, Quaternion and Euler Angle classes that combine into an abstract Object class, from which all in-game objects are derived. In the future, it will be able to do Procedural Terrain Destruction and Physics Simulations.",
            "1" : "The core low-level classes have been thoroughly tested for sanity and performance. The Matrix and Vector are template classes that make use of various predefined types of certain byte depth, like U32C3, an unsigned integer of 32-bits depth with 3 channels. They are very user-friendly, the interface being something in between Eigen matrices and OpenCV matrices. There are also specialized constructors that create various rotation, translation, scaling or compound matrices. The coordinate-storing classes, Quaternion, Euler Angles and Rotation Matrices, are very easily interchangeable and have various helpers and automations that make them easy to use. The abstract Object class uses Quaternions to store rotation, but this can easily be changed.",
            "2" : "The procedural terrain is made using Perlin Noise and Fractals to enhance realism. The noise is generated from 0 using our own vector class and a smooth-step interpolation function. As the other generated primitives, we compute collision, normals and topography for it. The resolution, scaling and other variables are left to the user, offering a lot of  degrees of freedom for how the terrain should look. For a full explanation, please check the Docs in the GitHub repo. It also contains some demos to test, compiled with CMake."
        },
        "images": {
            "0": "",
            "1": ""
        }
    },

    "Market": {
        "name": "Financial Market Simulation",
        "par_num": "3",
        "img": "false",
        "text": {
            "0": "A financial market simulator with a varying number of securities and agents implemented in Python using Numpy. It was initially made to test the effects and behavior of prediction markets and overall speculation-driven agents on a market user-structure. It contains a complex Command Line Interface that allows the user to change a lot of variables before running the simulation. It also allows them to set breakpoints, where the simulation automatically pauses and captures a full state snapshot for visualization. If you choose not to use the CLI, it also contains various command-line level arguments and options.",
            "1": "It is initialized with a set number of participants that each have a random sum of money distributed in an exponential fashion, random risk tolerance variable that updates after each cycle, personal bias vector to introduce irrational behavior as well as buy and sell algorithms. Each cycle, the participants update most of the variables based on the results of the last cycle.",
            "2": "The Market Maker algorithm is pretty straight forward, it caches and completes orders and partial orders.  The price of the order can either be set by the participant or automatically executed to the highest ( or lowest ) already existing order. The state of the market can be dumped at any point during the simulation, displaying nicely in the console window. As this program was developed on Linux, it makes use of ANSI colors and console commands to display the data in a nice user readable format, which might not work on Windows."
        }
    }
}
